// Code generated by github.com/vektah/gqlgen, DO NOT EDIT.

package graphapi

import (
	"bytes"
	context "context"
	strconv "strconv"

	graphql "github.com/vektah/gqlgen/graphql"
	introspection "github.com/vektah/gqlgen/neelance/introspection"
	query "github.com/vektah/gqlgen/neelance/query"
	schema "github.com/vektah/gqlgen/neelance/schema"
)

// MakeExecutableSchema creates an ExecutableSchema from the Resolvers interface.
func MakeExecutableSchema(resolvers Resolvers) graphql.ExecutableSchema {
	return &executableSchema{resolvers: resolvers}
}

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(resolvers ResolverRoot) graphql.ExecutableSchema {
	return MakeExecutableSchema(shortMapper{r: resolvers})
}

type Resolvers interface {
	Mutation_createRepository(ctx context.Context, repo RepositoryInput) (*Repository, error)
	Mutation_createBundle(ctx context.Context, params BundleInput) (*Bundle, error)
	Mutation_deleteRepository(ctx context.Context, id string) (*Repository, error)
	Mutation_deleteBranch(ctx context.Context, repository string, branch string) (*string, error)
	Mutation_deleteTag(ctx context.Context, repository string, tag string) (*string, error)

	Query_repositories(ctx context.Context) ([]Repository, error)
	Query_repository(ctx context.Context, name string) (*Repository, error)

	Repository_tags(ctx context.Context, obj *Repository) ([]BundleRef, error)
	Repository_branches(ctx context.Context, obj *Repository) ([]BundleRef, error)
	Repository_bundle(ctx context.Context, obj *Repository, id string) (*Bundle, error)
	Repository_snapshot(ctx context.Context, obj *Repository, id string) (*Snapshot, error)
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
	Repository() RepositoryResolver
}
type MutationResolver interface {
	CreateRepository(ctx context.Context, repo RepositoryInput) (*Repository, error)
	CreateBundle(ctx context.Context, params BundleInput) (*Bundle, error)
	DeleteRepository(ctx context.Context, id string) (*Repository, error)
	DeleteBranch(ctx context.Context, repository string, branch string) (*string, error)
	DeleteTag(ctx context.Context, repository string, tag string) (*string, error)
}
type QueryResolver interface {
	Repositories(ctx context.Context) ([]Repository, error)
	Repository(ctx context.Context, name string) (*Repository, error)
}
type RepositoryResolver interface {
	Tags(ctx context.Context, obj *Repository) ([]BundleRef, error)
	Branches(ctx context.Context, obj *Repository) ([]BundleRef, error)
	Bundle(ctx context.Context, obj *Repository, id string) (*Bundle, error)
	Snapshot(ctx context.Context, obj *Repository, id string) (*Snapshot, error)
}

type shortMapper struct {
	r ResolverRoot
}

func (s shortMapper) Mutation_createRepository(ctx context.Context, repo RepositoryInput) (*Repository, error) {
	return s.r.Mutation().CreateRepository(ctx, repo)
}

func (s shortMapper) Mutation_createBundle(ctx context.Context, params BundleInput) (*Bundle, error) {
	return s.r.Mutation().CreateBundle(ctx, params)
}

func (s shortMapper) Mutation_deleteRepository(ctx context.Context, id string) (*Repository, error) {
	return s.r.Mutation().DeleteRepository(ctx, id)
}

func (s shortMapper) Mutation_deleteBranch(ctx context.Context, repository string, branch string) (*string, error) {
	return s.r.Mutation().DeleteBranch(ctx, repository, branch)
}

func (s shortMapper) Mutation_deleteTag(ctx context.Context, repository string, tag string) (*string, error) {
	return s.r.Mutation().DeleteTag(ctx, repository, tag)
}

func (s shortMapper) Query_repositories(ctx context.Context) ([]Repository, error) {
	return s.r.Query().Repositories(ctx)
}

func (s shortMapper) Query_repository(ctx context.Context, name string) (*Repository, error) {
	return s.r.Query().Repository(ctx, name)
}

func (s shortMapper) Repository_tags(ctx context.Context, obj *Repository) ([]BundleRef, error) {
	return s.r.Repository().Tags(ctx, obj)
}

func (s shortMapper) Repository_branches(ctx context.Context, obj *Repository) ([]BundleRef, error) {
	return s.r.Repository().Branches(ctx, obj)
}

func (s shortMapper) Repository_bundle(ctx context.Context, obj *Repository, id string) (*Bundle, error) {
	return s.r.Repository().Bundle(ctx, obj, id)
}

func (s shortMapper) Repository_snapshot(ctx context.Context, obj *Repository, id string) (*Snapshot, error) {
	return s.r.Repository().Snapshot(ctx, obj, id)
}

type executableSchema struct {
	resolvers Resolvers
}

func (e *executableSchema) Schema() *schema.Schema {
	return parsedSchema
}

func (e *executableSchema) Query(ctx context.Context, op *query.Operation) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e.resolvers}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Query(ctx, op.Selections)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:   buf,
		Errors: ec.Errors,
	}
}

func (e *executableSchema) Mutation(ctx context.Context, op *query.Operation) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e.resolvers}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Mutation(ctx, op.Selections)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:   buf,
		Errors: ec.Errors,
	}
}

func (e *executableSchema) Subscription(ctx context.Context, op *query.Operation) func() *graphql.Response {
	return graphql.OneShot(graphql.ErrorResponse(ctx, "subscriptions are not supported"))
}

type executionContext struct {
	*graphql.RequestContext

	resolvers Resolvers
}

var bundleImplementors = []string{"Bundle"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Bundle(ctx context.Context, sel []query.Selection, obj *Bundle) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, bundleImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Bundle")
		case "id":
			out.Values[i] = ec._Bundle_id(ctx, field, obj)
		case "message":
			out.Values[i] = ec._Bundle_message(ctx, field, obj)
		case "parents":
			out.Values[i] = ec._Bundle_parents(ctx, field, obj)
		case "changes":
			out.Values[i] = ec._Bundle_changes(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._Bundle_timestamp(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Bundle_id(ctx context.Context, field graphql.CollectedField, obj *Bundle) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Bundle"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.ID
	return graphql.MarshalID(res)
}

func (ec *executionContext) _Bundle_message(ctx context.Context, field graphql.CollectedField, obj *Bundle) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Bundle"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Message
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) _Bundle_parents(ctx context.Context, field graphql.CollectedField, obj *Bundle) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Bundle"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Parents
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			if res[idx1] == nil {
				return graphql.Null
			}
			return ec._Bundle(ctx, field.Selections, res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _Bundle_changes(ctx context.Context, field graphql.CollectedField, obj *Bundle) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Bundle"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Changes
	return ec._ChangeSet(ctx, field.Selections, &res)
}

func (ec *executionContext) _Bundle_timestamp(ctx context.Context, field graphql.CollectedField, obj *Bundle) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Bundle"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Timestamp
	return graphql.MarshalTime(res)
}

var bundleRefImplementors = []string{"BundleRef"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _BundleRef(ctx context.Context, sel []query.Selection, obj *BundleRef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, bundleRefImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BundleRef")
		case "id":
			out.Values[i] = ec._BundleRef_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._BundleRef_name(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _BundleRef_id(ctx context.Context, field graphql.CollectedField, obj *BundleRef) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "BundleRef"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.ID
	return graphql.MarshalID(res)
}

func (ec *executionContext) _BundleRef_name(ctx context.Context, field graphql.CollectedField, obj *BundleRef) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "BundleRef"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name
	if res == nil {
		return graphql.Null
	}
	return ec._Named(ctx, field.Selections, res)
}

var changeSetImplementors = []string{"ChangeSet"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ChangeSet(ctx context.Context, sel []query.Selection, obj *ChangeSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, changeSetImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChangeSet")
		case "added":
			out.Values[i] = ec._ChangeSet_added(ctx, field, obj)
		case "deleted":
			out.Values[i] = ec._ChangeSet_deleted(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _ChangeSet_added(ctx context.Context, field graphql.CollectedField, obj *ChangeSet) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "ChangeSet"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Added
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._VersionedObject(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _ChangeSet_deleted(ctx context.Context, field graphql.CollectedField, obj *ChangeSet) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "ChangeSet"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Deleted
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._VersionedObject(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

var contributorImplementors = []string{"Contributor"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Contributor(ctx context.Context, sel []query.Selection, obj *Contributor) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, contributorImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Contributor")
		case "name":
			out.Values[i] = ec._Contributor_name(ctx, field, obj)
		case "email":
			out.Values[i] = ec._Contributor_email(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Contributor_name(ctx context.Context, field graphql.CollectedField, obj *Contributor) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Contributor"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Contributor_email(ctx context.Context, field graphql.CollectedField, obj *Contributor) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Contributor"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Email
	return graphql.MarshalString(res)
}

var mutationImplementors = []string{"Mutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Mutation(ctx context.Context, sel []query.Selection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, mutationImplementors, ec.Variables)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Mutation",
	})

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createRepository":
			out.Values[i] = ec._Mutation_createRepository(ctx, field)
		case "createBundle":
			out.Values[i] = ec._Mutation_createBundle(ctx, field)
		case "deleteRepository":
			out.Values[i] = ec._Mutation_deleteRepository(ctx, field)
		case "deleteBranch":
			out.Values[i] = ec._Mutation_deleteBranch(ctx, field)
		case "deleteTag":
			out.Values[i] = ec._Mutation_deleteTag(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Mutation_createRepository(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 RepositoryInput
	if tmp, ok := field.Args["repo"]; ok {
		var err error
		arg0, err = UnmarshalRepositoryInput(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["repo"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Mutation"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation_createRepository(ctx, args["repo"].(RepositoryInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Repository)
	if res == nil {
		return graphql.Null
	}
	return ec._Repository(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createBundle(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 BundleInput
	if tmp, ok := field.Args["params"]; ok {
		var err error
		arg0, err = UnmarshalBundleInput(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["params"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Mutation"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation_createBundle(ctx, args["params"].(BundleInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Bundle)
	if res == nil {
		return graphql.Null
	}
	return ec._Bundle(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteRepository(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := field.Args["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["id"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Mutation"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation_deleteRepository(ctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Repository)
	if res == nil {
		return graphql.Null
	}
	return ec._Repository(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteBranch(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := field.Args["repository"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["repository"] = arg0
	var arg1 string
	if tmp, ok := field.Args["branch"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["branch"] = arg1
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Mutation"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation_deleteBranch(ctx, args["repository"].(string), args["branch"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) _Mutation_deleteTag(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := field.Args["repository"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["repository"] = arg0
	var arg1 string
	if tmp, ok := field.Args["tag"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["tag"] = arg1
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Mutation"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation_deleteTag(ctx, args["repository"].(string), args["tag"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var namedImplementors = []string{"Named"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Named(ctx context.Context, sel []query.Selection, obj *Named) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, namedImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Named")
		case "value":
			out.Values[i] = ec._Named_value(ctx, field, obj)
		case "type":
			out.Values[i] = ec._Named_type(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Named_value(ctx context.Context, field graphql.CollectedField, obj *Named) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Named"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Value
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Named_type(ctx context.Context, field graphql.CollectedField, obj *Named) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Named"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Type
	return res
}

var queryImplementors = []string{"Query"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Query(ctx context.Context, sel []query.Selection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, queryImplementors, ec.Variables)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
	})

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "repositories":
			out.Values[i] = ec._Query_repositories(ctx, field)
		case "repository":
			out.Values[i] = ec._Query_repository(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Query_repositories(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Query_repositories(ctx)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.([]Repository)
		arr1 := graphql.Array{}
		for idx1 := range res {
			arr1 = append(arr1, func() graphql.Marshaler {
				rctx := graphql.GetResolverContext(ctx)
				rctx.PushIndex(idx1)
				defer rctx.Pop()
				return ec._Repository(ctx, field.Selections, &res[idx1])
			}())
		}
		return arr1
	})
}

func (ec *executionContext) _Query_repository(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := field.Args["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Query_repository(ctx, args["name"].(string))
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*Repository)
		if res == nil {
			return graphql.Null
		}
		return ec._Repository(ctx, field.Selections, res)
	})
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Query"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := ec.introspectSchema()
	if res == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := field.Args["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Query"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := ec.introspectType(args["name"].(string))
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

var repositoryImplementors = []string{"Repository"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Repository(ctx context.Context, sel []query.Selection, obj *Repository) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, repositoryImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Repository")
		case "name":
			out.Values[i] = ec._Repository_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Repository_description(ctx, field, obj)
		case "defaultBranch":
			out.Values[i] = ec._Repository_defaultBranch(ctx, field, obj)
		case "tags":
			out.Values[i] = ec._Repository_tags(ctx, field, obj)
		case "branches":
			out.Values[i] = ec._Repository_branches(ctx, field, obj)
		case "bundle":
			out.Values[i] = ec._Repository_bundle(ctx, field, obj)
		case "snapshot":
			out.Values[i] = ec._Repository_snapshot(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Repository_name(ctx context.Context, field graphql.CollectedField, obj *Repository) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Repository"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Repository_description(ctx context.Context, field graphql.CollectedField, obj *Repository) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Repository"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) _Repository_defaultBranch(ctx context.Context, field graphql.CollectedField, obj *Repository) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Repository"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.DefaultBranch
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Repository_tags(ctx context.Context, field graphql.CollectedField, obj *Repository) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Repository",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Repository_tags(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.([]BundleRef)
		arr1 := graphql.Array{}
		for idx1 := range res {
			arr1 = append(arr1, func() graphql.Marshaler {
				rctx := graphql.GetResolverContext(ctx)
				rctx.PushIndex(idx1)
				defer rctx.Pop()
				return ec._BundleRef(ctx, field.Selections, &res[idx1])
			}())
		}
		return arr1
	})
}

func (ec *executionContext) _Repository_branches(ctx context.Context, field graphql.CollectedField, obj *Repository) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Repository",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Repository_branches(ctx, obj)
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.([]BundleRef)
		arr1 := graphql.Array{}
		for idx1 := range res {
			arr1 = append(arr1, func() graphql.Marshaler {
				rctx := graphql.GetResolverContext(ctx)
				rctx.PushIndex(idx1)
				defer rctx.Pop()
				return ec._BundleRef(ctx, field.Selections, &res[idx1])
			}())
		}
		return arr1
	})
}

func (ec *executionContext) _Repository_bundle(ctx context.Context, field graphql.CollectedField, obj *Repository) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := field.Args["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["id"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Repository",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Repository_bundle(ctx, obj, args["id"].(string))
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*Bundle)
		if res == nil {
			return graphql.Null
		}
		return ec._Bundle(ctx, field.Selections, res)
	})
}

func (ec *executionContext) _Repository_snapshot(ctx context.Context, field graphql.CollectedField, obj *Repository) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := field.Args["id"]; ok {
		var err error
		arg0, err = graphql.UnmarshalID(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["id"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Repository",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Repository_snapshot(ctx, obj, args["id"].(string))
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*Snapshot)
		if res == nil {
			return graphql.Null
		}
		return ec._Snapshot(ctx, field.Selections, res)
	})
}

var snapshotImplementors = []string{"Snapshot"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Snapshot(ctx context.Context, sel []query.Selection, obj *Snapshot) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, snapshotImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Snapshot")
		case "id":
			out.Values[i] = ec._Snapshot_id(ctx, field, obj)
		case "parents":
			out.Values[i] = ec._Snapshot_parents(ctx, field, obj)
		case "bundle":
			out.Values[i] = ec._Snapshot_bundle(ctx, field, obj)
		case "previousCommits":
			out.Values[i] = ec._Snapshot_previousCommits(ctx, field, obj)
		case "objects":
			out.Values[i] = ec._Snapshot_objects(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._Snapshot_timestamp(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Snapshot_id(ctx context.Context, field graphql.CollectedField, obj *Snapshot) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Snapshot"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.ID
	return graphql.MarshalID(res)
}

func (ec *executionContext) _Snapshot_parents(ctx context.Context, field graphql.CollectedField, obj *Snapshot) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Snapshot"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Parents
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return graphql.MarshalString(res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _Snapshot_bundle(ctx context.Context, field graphql.CollectedField, obj *Snapshot) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Snapshot"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Bundle
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) _Snapshot_previousCommits(ctx context.Context, field graphql.CollectedField, obj *Snapshot) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Snapshot"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.PreviousCommits
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return graphql.MarshalString(res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _Snapshot_objects(ctx context.Context, field graphql.CollectedField, obj *Snapshot) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Snapshot"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Objects
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._VersionedObject(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _Snapshot_timestamp(ctx context.Context, field graphql.CollectedField, obj *Snapshot) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Snapshot"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Timestamp
	return graphql.MarshalTime(res)
}

var versionedObjectImplementors = []string{"VersionedObject"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _VersionedObject(ctx context.Context, sel []query.Selection, obj *VersionedObject) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, versionedObjectImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VersionedObject")
		case "id":
			out.Values[i] = ec._VersionedObject_id(ctx, field, obj)
		case "path":
			out.Values[i] = ec._VersionedObject_path(ctx, field, obj)
		case "mtime":
			out.Values[i] = ec._VersionedObject_mtime(ctx, field, obj)
		case "mode":
			out.Values[i] = ec._VersionedObject_mode(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _VersionedObject_id(ctx context.Context, field graphql.CollectedField, obj *VersionedObject) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "VersionedObject"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.ID
	return graphql.MarshalID(res)
}

func (ec *executionContext) _VersionedObject_path(ctx context.Context, field graphql.CollectedField, obj *VersionedObject) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "VersionedObject"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Path
	return graphql.MarshalString(res)
}

func (ec *executionContext) _VersionedObject_mtime(ctx context.Context, field graphql.CollectedField, obj *VersionedObject) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "VersionedObject"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Mtime
	return graphql.MarshalTime(res)
}

func (ec *executionContext) _VersionedObject_mode(ctx context.Context, field graphql.CollectedField, obj *VersionedObject) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "VersionedObject"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Mode
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __DirectiveImplementors = []string{"__Directive"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Directive(ctx context.Context, sel []query.Selection, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __DirectiveImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Locations()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return graphql.MarshalString(res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Args()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___InputValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

var __EnumValueImplementors = []string{"__EnumValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___EnumValue(ctx context.Context, sel []query.Selection, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __EnumValueImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.IsDeprecated()
	return graphql.MarshalBoolean(res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.DeprecationReason()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __FieldImplementors = []string{"__Field"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Field(ctx context.Context, sel []query.Selection, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __FieldImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Args()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___InputValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Type()
	return ec.___Type(ctx, field.Selections, &res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.IsDeprecated()
	return graphql.MarshalBoolean(res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.DeprecationReason()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __InputValueImplementors = []string{"__InputValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___InputValue(ctx context.Context, sel []query.Selection, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __InputValueImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Type()
	return ec.___Type(ctx, field.Selections, &res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.DefaultValue()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __SchemaImplementors = []string{"__Schema"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Schema(ctx context.Context, sel []query.Selection, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __SchemaImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Types()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Type(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.QueryType()
	return ec.___Type(ctx, field.Selections, &res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.MutationType()
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.SubscriptionType()
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Directives()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Directive(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

var __TypeImplementors = []string{"__Type"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Type(ctx context.Context, sel []query.Selection, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __TypeImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Kind()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := field.Args["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["includeDeprecated"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Fields(args["includeDeprecated"].(bool))
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Field(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Interfaces()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Type(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.PossibleTypes()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Type(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := field.Args["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["includeDeprecated"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.EnumValues(args["includeDeprecated"].(bool))
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___EnumValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.InputFields()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___InputValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.OfType()
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func UnmarshalBundleInput(v interface{}) (BundleInput, error) {
	var it BundleInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "repository":
			var err error
			it.Repository, err = graphql.UnmarshalID(v)
			if err != nil {
				return it, err
			}
		case "branch":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalID(v)
				it.Branch = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "message":
			var err error
			it.Message, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "changes":
			var err error
			var ptr1 ChangeSetInput
			if v != nil {
				ptr1, err = UnmarshalChangeSetInput(v)
				it.Changes = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalChangeSetInput(v interface{}) (ChangeSetInput, error) {
	var it ChangeSetInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "added":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				}
			}
			it.Added = make([]ObjectInput, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Added[idx1], err = UnmarshalObjectInput(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "deleted":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				}
			}
			it.Deleted = make([]ObjectInput, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Deleted[idx1], err = UnmarshalObjectInput(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalObjectInput(v interface{}) (ObjectInput, error) {
	var it ObjectInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = graphql.UnmarshalID(v)
			if err != nil {
				return it, err
			}
		case "path":
			var err error
			it.Path, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "mtime":
			var err error
			it.Mtime, err = graphql.UnmarshalTime(v)
			if err != nil {
				return it, err
			}
		case "mode":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Mode = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalRepositoryInput(v interface{}) (RepositoryInput, error) {
	var it RepositoryInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Description = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) introspectSchema() *introspection.Schema {
	return introspection.WrapSchema(parsedSchema)
}

func (ec *executionContext) introspectType(name string) *introspection.Type {
	t := parsedSchema.Resolve(name)
	if t == nil {
		return nil
	}
	return introspection.WrapType(t)
}

var parsedSchema = schema.MustParse(`# Top-Level query object as entry point to the graphq query
type Query {
    # List the repositories known by trumpet
    repositories: [Repository!]!
    # Get a repository by name
    repository(name: String!): Repository
}

# All the available methods for creating, updating and deleting data.
type Mutation {
  # Create an empty repository in the server
  createRepository(repo: RepositoryInput!): Repository

  # Create a new bundle from a changeset and a message
  createBundle(params: BundleInput!): Bundle

  # Delete a repository from the server, this will only be possible if there are no dependencies
  # on this repository anymore
  deleteRepository(id: ID!): Repository

  # Delete a branch from the repository, this will only be possible if there are no dependencies
  # on this branch anywhere
  deleteBranch(repository: ID!, branch: String!): String

  # Delete a tag from the repository, this will only be possible if there are no dependencies
  # on this tag anywhere
  deleteTag(repository: ID!, tag: String!): String
}

# A repository contains a group of files that are versioned over time.
#
# Repositories can contain several different diverging timelines. It's helpful to think about repositories as topics.
type Repository {

    # Name of the repository, this needs to be a DNS safe name.
    name: String!

    # A description of what the repository is about.
    # This field accepts github flavored markdown.
    description: String

    # The default branch for this repository
    defaultBranch: String!

    # Tagged bundles, if any of the repository.
    #
    # A tag represents a fixed point in history for a repository.
    # Tags are expected to be stable and never change once they've been published.
    #
    # For consumers of a tag it is important that they can depend on the tag always being the same.
    tags: [BundleRef!]

    # Branches, if any of the repository.
    #
    # A branch represents a pointer to the top of a particular timeline.
    # Branches can be seen as alternative timelines for a particular topic.
    branches: [BundleRef!]

    # Get a bundle by id, the id can be a bundle id, a branch or tag name.
    bundle(id: ID!): Bundle

    # Get a snapshot for a bundle by id. The id can be a snapshot id or a bundle id
    snapshot(id: ID!): Snapshot
}

# Input required to create a new, empty repository
input RepositoryInput {

    # A unique name for the repository, this needs to be a DNS safe name
    #
    # So no longer than 53 characters and [a-zA-Z0-9-]+
    name: String!

    # An optional description of what the repository is about.
    #
    # This field accepts github flavored markdown.
    description: String
}

# The possible types a name can be for
enum NameType {
    # Detached for when a bundle ref refers to an unnamed bundle
    Detached
    # Branch for when the name refers to a branch
    Branch
    # Tag for when the name refers to a tag
    Tag
}

# A name for bundle refs
type Named {
    # The name of ref
    value: String!

    # The type of the name
    type: NameType!
}

# A bundle reference is a pointer to a bundle id, with an optional name
type BundleRef {
    # The id of the bundle
    id: ID!

    # The name of the bundle, when provided
    name: Named
}

# Input parameters for creating a new bundle
input BundleInput {
  # The repository to create the bundle in
  repository: ID!

  # The branch to create the bundle for
  branch: ID

  # The message that describes the changes for this bundle
  message: String!

  # The changes made to the bundle
  changes: ChangeSetInput
}

# Captures the changes made to the file tree of a snapshot as a snapshot
input ChangeSetInput {
    # Added files, so newly created ones
    added: [ObjectInput!]
    # Deleted files, so files that dissappeared
    deleted: [ObjectInput!]
}

# A versioned object. This is identified by the hash of its content.
input ObjectInput {

    # The hash of the content that should appear at the given path
    id: ID!

    # The path of the file within the workspace
    path: String!

    # The time this file was last modified
    mtime: Time!

    # The unix file permissions (eg: 0644)
    mode: String
}



# A bundle represents a change set with some metadata about how created it
# and where it's located in the timeline
type Bundle {
    # The ID of the bundle.
    #
    # This is created from the timestamp, the parent hashes,
    # the root hash of the change set and the message.
    id: ID!

    # The bundle message that describes what went in this bundle.
    message: String

    # The parents to this bundle.
    parents: [Bundle]

    # The changes to the repository in this bundle
    changes: ChangeSet!

    # The timestamp for when this bundle was made
    timestamp: Time!
}

# A snapshot represents the composed list of paths in a workspace
# for materializing.
type Snapshot {
  # The ID of the snapshot
  id: ID!

  # The parent snapshots to this one
  parents: [String!]

  # The bundle ID that this snapshot represents
  bundle: String

  # The parent bundles that went into this snapshots bundle
  previousCommits: [String!]

  # The objects contained in the snapshot
  objects: [VersionedObject!]!

  # The time this snaphost was created
  timestamp: Time!
}

# A versioned object. This is identified by the hash of its content.
type VersionedObject {

    # The hash of the content that should appear at the given path
    id: ID!

    # The path of the file within the workspace
    path: String!

    # The time this file was last modified
    mtime: Time!

    # The unix file permissions (eg: 0644)
    mode: String
}

# Captures the changes made to the file tree of a snapshot
type ChangeSet {
    # Added files, so newly created ones
    added: [VersionedObject!]
    # Deleted files, so files that dissappeared
    deleted: [VersionedObject!]
}

# A contributor to an element in Trumpet
#
# Both fields are required so that we always know who made the changes to the files
type Contributor {
    # Name of the contributor
    name: String!
    # Email address of the contributor
    email: String!
}

# Represents an ISO-8601 date
scalar Time
`)
